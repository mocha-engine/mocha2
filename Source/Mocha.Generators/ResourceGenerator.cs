using Microsoft.CodeAnalysis;
using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Threading;

namespace Mocha.Generators
{
	[Generator( LanguageNames.CSharp )]
	public class ResourceGenerator : IIncrementalGenerator
	{
		private const string OutputFileHint = "ResourceGen.g.cs";

		private const string ResourceAttribute = "Mocha.ResourceAttribute";

		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			var provider = context.SyntaxProvider.ForAttributeWithMetadataName(ResourceAttribute, SyntaxPredicate, TransformResourceAttribute)
				.Where(obj => obj != default);

			context.RegisterSourceOutput(provider.Collect(), Execute);
		}

		private void Execute(SourceProductionContext context, ImmutableArray<ResourceData> resourceData)
		{
			using var output = new StringWriter();
			using var writer = new IndentedTextWriter(output);

			writer.WriteLine("// <auto-generated/>");
			writer.WriteLine();
			writer.WriteLine("using System.Text.Json;");

			var groups = resourceData.GroupBy(resource => resource.ContainingNamespace);

			foreach ( var group in groups )
			{
				var firstEntry = group.First();
				var containingNamespace = firstEntry.ContainingNamespace;

				// Start group namespace
				if ( !string.IsNullOrWhiteSpace( containingNamespace ) )
				{
					writer.WriteLine($"namespace {containingNamespace}");
					writer.WriteLine("{");
					writer.Indent++;
				}

				foreach ( var entry in group )
				{
					// Start entry type
					writer.WriteLine($"partial struct {entry.TypeName}");
					writer.WriteLine("{");
					writer.Indent++;

					// Start Load(string)
					writer.WriteLine("/// <summary>");
					writer.WriteLine("/// <para>");
					writer.WriteLine($"/// Loads a <see cref=\"{entry.TypeName}\" /> structure from a file using <see cref=\"FileSystem.Content\" />");
					writer.WriteLine("/// </para>");
					writer.WriteLine("/// <para>");
					writer.WriteLine("/// <b>(Auto-generated)</b>");
					writer.WriteLine("/// </para>");
					writer.WriteLine("/// </summary>");

					writer.WriteLine($"public static {entry.TypeName} Load( string filePath )");
					writer.WriteLine("{");
					writer.Indent++;

					writer.WriteLine("var file = FileSystem.Content.ReadAllText( filePath );");
					writer.WriteLine($"return JsonSerializer.Deserialize<{entry.TypeName}>( file );");

					writer.Indent--;
					writer.WriteLine("}");
					// End Load(string)

					// Start Load(byte[])
					writer.WriteLine("/// <summary>");
					writer.WriteLine("/// <para>");
					writer.WriteLine($"/// Loads a <see cref=\"{entry.TypeName}\" /> structure from a data array.");
					writer.WriteLine("/// </para>");
					writer.WriteLine("/// <para>");
					writer.WriteLine("/// <b>(Auto-generated)</b>");
					writer.WriteLine("/// </para>");
					writer.WriteLine("/// </summary>");

					writer.WriteLine($"public static {entry.TypeName} Load( byte[] data )");
					writer.WriteLine("{");
					writer.Indent++;

					writer.WriteLine($"return JsonSerializer.Deserialize<{entry.TypeName}>( data );");

					writer.Indent--;
					writer.WriteLine("}");
					// End Load(byte[])

					writer.Indent--;
					writer.WriteLine("}");
					// End entry type
				}

				if (!string.IsNullOrWhiteSpace(containingNamespace))
				{
					writer.Indent--;
					writer.WriteLine("}");
				}
				// End group namespace
			}

			context.CancellationToken.ThrowIfCancellationRequested();
			context.AddSource(OutputFileHint, output.ToString());
		}

		// Will always be true because of the AttributeUsage constraint.
		private bool SyntaxPredicate(SyntaxNode node, CancellationToken token) => true;
		private ResourceData TransformResourceAttribute(GeneratorAttributeSyntaxContext context, CancellationToken token)
		{
			var containingNamespace = context.TargetSymbol.ContainingNamespace.IsGlobalNamespace
				? null
				: context.TargetSymbol.ContainingNamespace.ToDisplayString();
			var typeName = context.TargetSymbol.Name;

			return new ResourceData(containingNamespace, typeName, []);
		}

		private readonly record struct ResourceData
		{
			public readonly string? ContainingNamespace;
			public readonly string TypeName;

			public readonly bool IsError;
			public readonly ImmutableArray<Diagnostic> Diagnostics;

			public ResourceData( string? containingNamespace, string typeName, ImmutableArray<Diagnostic> diagnostics )
			{
				ContainingNamespace = containingNamespace;
				TypeName = typeName;

				IsError = false;
				Diagnostics = diagnostics;
			}

			public ResourceData( ImmutableArray<Diagnostic> diagnostics )
			{
				ContainingNamespace = null;
				TypeName = string.Empty;

				IsError = true;
				Diagnostics = diagnostics;
			}
		}
	}
}
